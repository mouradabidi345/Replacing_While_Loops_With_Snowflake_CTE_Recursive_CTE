DECLARE @WEEKS_OPTIONS TABLE 
(
NUMBER_OF_WEEKS INT
)

 

DECLARE @RESULTS TABLE
(
        DISTRIBUTORID BIGINT
    , COMMPERIODID INT
    , PREVIOUS_COMM_PERIOD INT
    , PREVIOUS_COMM_PERIOD_END INT
    , NEW_RANK INT
    , PREVIOUS_RANK INT
    , NUM_OF_RANKS INT
    , WEEKS_TO_ADVANCE INT
)

 

DECLARE @WEEKS_NUMBER INT
DECLARE @WEEKS_COUNT INT

 

--MOST RECENTLY CLOSED WEEK FOR USE DOWNSTREAM
DECLARE @RECENT_CLOSE_WEEK INT = 
    (
    SELECT
        MAX(CP.PeriodID)
    FROM LU_Tbl_CommPeriods CP
    WHERE  CP.ISCLOSED = 1
    )

 

DECLARE @COMMPERIOD_START_PREP INT = 
    (
    SELECT
        CP.PeriodID
    FROM LU_Tbl_CommPeriods CP
    WHERE @STARTDATE BETWEEN CP.STARTDATE AND CP.ENDDATE
    AND CP.ISCLOSED = 1
    )

 

DECLARE @COMMPERIOD_END_PREP INT =
    (
    SELECT
        CP.PeriodID
    FROM LU_Tbl_CommPeriods CP
    WHERE @ENDDATE BETWEEN CP.STARTDATE AND CP.EndDate
    AND CP.ISCLOSED = 1
    ) 
    
DECLARE @COMMPERIOD_START INT = 
    (
    SELECT
        CASE
            WHEN @COMMPERIOD_START_PREP IS NULL
            THEN (SELECT (@RECENT_CLOSE_WEEK - @NUM_WEEKS))
            ELSE @COMMPERIOD_START_PREP
            END
    )

 

DECLARE @COMMPERIOD_END INT = 
    (
    SELECT
        CASE
            WHEN @COMMPERIOD_END_PREP IS NULL
            THEN @RECENT_CLOSE_WEEK
            ELSE @COMMPERIOD_END_PREP
            END
    )

 

--SELECT @RECENT_CLOSE_WEEK ,@STARTDATE, @ENDDATE, @COMMPERIOD_START, @COMMPERIOD_END, @COMMPERIOD_START_PREP, @COMMPERIOD_END_PREP

 


--populate temp variable table:
INSERT INTO @WEEKS_OPTIONS (NUMBER_OF_WEEKS) values(0), (1), (2), (3), (4), (5), (6), (7), (8), (9), (10)
DELETE FROM @WEEKS_OPTIONS WHERE NUMBER_OF_WEEKS > @NUM_WEEKS

 

/*
--qa TEMP TABLE WEEKS OPTIONS
SELECT *
FROM @WEEKS_OPTIONS

 

DELETE FROM @WEEKS_OPTIONS WHERE NUMBER_OF_WEEKS > @NUM_WEEKS

 

SELECT *
FROM @WEEKS_OPTIONS
--DONE WITH TEMP WEEKS OPTIONS QA
*/

 

SELECT 
        RA.*
INTO #RELEVANT_RANK_ADVANCEMENTS
FROM Ranks_Azure RA
WHERE RA.PREVIOUSRANKID > 4
    AND RA.CommPeriodID BETWEEN @COMMPERIOD_START AND @COMMPERIOD_END

 


--NARROW THE SCOPE TO ONLY THOSE WHO MAY MEET THE REQUIREMENTS OF REPORT (i.e., have at least a delta equal to the min# ranks selected by user
SELECT 
        DISTRIBUTORID
    , MAX(RRA.NEWRANKID) [MAX_RANK]
    , MIN(RRA.PREVIOUSRANKID) [MIN_RANK]
INTO #POSSIBLES
FROM #RELEVANT_RANK_ADVANCEMENTS RRA
GROUP BY DISTRIBUTORID
HAVING (MAX(RRA.NEWRANKID) - MIN(RRA.PREVIOUSRANKID)) >= @NUM_RANKS_MIN

 

 

--SELECT * FROM @WEEKS_OPTIONS

 

--SELECT * FROM #POSSIBLES

 

SELECT RRA.*
INTO #BASE_FOR_LOOP
FROM #RELEVANT_RANK_ADVANCEMENTS RRA
    INNER JOIN #POSSIBLES P
        ON RRA.DISTRIBUTORID = P.DISTRIBUTORID
ORDER BY RRA.DISTRIBUTORID
    , RRA.COMMPERIODID

 

--thought: create a temp table that lists ALL numbers that are less than or equal to the minimum number of weeks selected above!! then write a query that loops through this?! Would this work?!

 

--======LOOP TO COMMENCE HERE========--

 

SET @WEEKS_COUNT = (SELECT COUNT(NUMBER_OF_WEEKS) FROM @WEEKS_OPTIONS)

 

--CREATE A PARAMETER TO SET IN THE LOOP
--TESTING THE CORE QUERY IN THE REPORT THAT COMPARES!

 

WHILE (@WEEKS_COUNT) > 0

 

BEGIN

 

SET @WEEKS_NUMBER = (SELECT TOP 1 NUMBER_OF_WEEKS FROM @WEEKS_OPTIONS)

 

--INSERT THE RESULTS ABOVE OR EQUAL TO NUMBER OF RANKS SELECTED TO A TABLE TO EXPORT IN FINAL RESULT SET

 

INSERT INTO @RESULTS
(
        DISTRIBUTORID 
    , COMMPERIODID 
    , PREVIOUS_COMM_PERIOD 
    , PREVIOUS_COMM_PERIOD_END 
    , NEW_RANK 
    , PREVIOUS_RANK 
    , NUM_OF_RANKS 
    , WEEKS_TO_ADVANCE 
)
SELECT
        P1.DISTRIBUTORID
    , P1.COMMPERIODID
    , P0.CommPeriodID [PREVIOUS_COMM_PERIOD]
    , PREVIOUS_COMM_PERIOD_END = P0.CommPeriodID - 1 --TO GET THE END DATE OF THE PREVIOUS WEEK!
    , MAX(P1.NEWRANKID) [NEW_RANK]
    , MIN(P0.PREVIOUSRANKID) [PREVIOUS_RANK]
    , NUM_OF_RANKS = (MAX(P1.NEWRANKID) - MIN(P0.PREVIOUSRANKID))
    ---=================================================================
    --USE THE PARAMETER SET IN THE LOOP HERE
    , WEEKS_TO_ADVANCE = @WEEKS_NUMBER +1 --WE NEED TO ADD 1 BECAUSE IT REFERENCES THE PREVIOUS RANK ID!!
FROM #BASE_FOR_LOOP P1
    INNER JOIN #BASE_FOR_LOOP P0
        ON P1.DISTRIBUTORID = P0.DISTRIBUTORID
        --USE THE PARAMETER SET IN THE LOOP HERE
        AND P1.COMMPERIODID - @WEEKS_NUMBER = P0.COMMPERIODID
GROUP BY 
        P1.DISTRIBUTORID
    , P1.COMMPERIODID
    , P0.CommPeriodID
HAVING (MAX(P1.NEWRANKID) - MIN(P0.PREVIOUSRANKID)) >= @NUM_RANKS_MIN

 

--DELETE ROW AND RESET VARIABLE
DELETE FROM @WEEKS_OPTIONS WHERE NUMBER_OF_WEEKS = @WEEKS_NUMBER
SET @WEEKS_COUNT = (SELECT COUNT(NUMBER_OF_WEEKS) FROM @WEEKS_OPTIONS)

 

END

 


SELECT 
        R.DISTRIBUTORID
    , [Name] = dbo.UDF_Name_Find(R.DistributorID)
    , R.COMMPERIODID [PERIOD_WEEK_ID]
    , CP1.ENDDATE [PERIOD_END_DATE]
    , R.PREVIOUS_COMM_PERIOD_END [PREVIOUS_PERIOD_WEEK_ID]
    , CP0.ENDDATE [PREVIOUS_PERIOD_END_DATE]
    , R.NEW_RANK
    , RL.DescLong [NEW_RANK_NAME]
    , R.PREVIOUS_RANK
    , RLPREV.DescLong [PREVIOUS_RANK_NAME]
    , R.NUM_OF_RANKS
    , R.WEEKS_TO_ADVANCE

 

FROM @RESULTS R
    INNER JOIN LU_Tbl_CommPeriods CP1
        ON R.COMMPERIODID = CP1.PERIODID
    INNER JOIN LU_Tbl_CommPeriods CP0
        ON R.PREVIOUS_COMM_PERIOD_END = CP0.PERIODID
    INNER JOIN RANKLEVEL RL 
        ON R.NEW_RANK = RL.[LEVEL]
    INNER JOIN RANKLEVEL RLPREV
        ON R.PREVIOUS_RANK = RLPREV.[LEVEL]


DROP TABLE #RELEVANT_RANK_ADVANCEMENTS
, #POSSIBLES
, #BASE_FOR_LOOP